@import 'sketch2unity.framework/sketch2unity.js'

const sketch = require('sketch/dom');
const contentType = "sketch2unity";
const version = "1.0.0";
var imageName = [];
var repeatImages = [];
var wrongGroups = [];
var customPanelDisabled = false;

var onRun = function(context) {
    const doc = context.document;
    const select = context.selection;

    var mocha = Mocha.sharedRuntime();
    var customPanel = mocha.valueForKey("Sketch2unity");
    if (customPanel == null || customPanel === undefined) {
        customPanelDisabled = true;
        catchErrorAlert ("onRun()", "customPanel is null or undefined");
    }
  
    if (doc.isDraft()) {
        [NSApp displayDialog:@"Please save the document to export." withTitle:@"Document Not Saved"];
        return;
    }
    if (doc.isDocumentEdited()) {
        var alert = [NSAlert alertWithMessageText:@"Document Not Saved" defaultButton:@"Save and Continue" alternateButton:@"Cancel" otherButton:@"Continue" informativeTextWithFormat:@"To capture the latest changes in this Sketch document, sketch2unity needs to save it first."];
        
        var response = [alert runModal];
        if (response == NSAlertDefaultReturn) {
            [doc showMessage:@"Saving document..."];
            [doc saveDocument:nil];
            while (doc.isDocumentEdited()) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            }
        }
        else if (response == NSAlertAlternateReturn) {
            return;
        }
        response = null;
        alert = null;
    }
    
    if (select.length == 0) {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Nothing Selected"];
        return;
    }
    if (select.length > 1) {
        [NSApp displayDialog:@"Please select only one Artboard Group to export." withTitle:@"Multiple Groups Selected"];
        return;
    }
    if (select[0].className() != "MSArtboardGroup" && select[0].className() != "MSLayerGroup") {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Single Layer Selected"];
        return;
    }
    
    var group = select[0];
    var groupName = String(group.name());
    var exportPath = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent() + "/FDPreview/sketch2unity/" + groupName + "/";
    
    console.log("--S2U export: " + groupName + " with path: " + exportPath);
    
    var jsonObj = exportJSON(group, exportPath, customPanel);
    var file = NSString.stringWithString(JSON.stringify(jsonObj, null, "\t"));
    [file writeToFile:exportPath + groupName + ".json" atomically:true encoding:NSUTF8StringEncoding error:null];
    
    var alertMessage = groupName + ".json and images are saved to: " + exportPath + "\n";
    if (repeatImages.length > 0) {
        alertMessage = alertMessage + "\nwith the following images repeat: \n";
        for (var i = 0; i < repeatImages.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + repeatImages[i] + "\n";
        }
    }
    if (wrongGroups.length > 0) {
        alertMessage = alertMessage + "\nwith more than one components in the groups: \n";
        for (var i = 0; i < wrongGroups.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + wrongGroups[i] + "\n";
        }
        alertMessage = alertMessage + "We have grouped the components for you. Please check them out.\n";
    }
    var copyString = "./sketch2unity/" + groupName + "/" + groupName + ".json";
    var pasteboard = NSPasteboard.generalPasteboard();
    pasteboard.clearContents();
    pasteboard.writeObjects([copyString]);
    alertMessage = alertMessage + "\nYou can load them in preview by copied path now!";
    [NSApp displayDialog:alertMessage withTitle:@"Document Exported!"];

    imageName.length = 0;
    repeatImages.length = 0;
    wrongGroups.length = 0;
    
    this.createWindow(groupName);
    [NSApp run];
    
}

var onSelectionChanged = function(context) {
    sketch2unity.onSelectionChanged(context);
};


function createWindow (name) {
    var threadDictionary = NSThread.mainThread().threadDictionary();
    var identifier = "Sketch2unityPreview";
    //log ("test threadDictionary: " + threadDictionary);
    
    if (threadDictionary[identifier]) {
        this.window = threadDictionary[identifier];
        this.window.makeKeyAndOrderFront_(this.window);
        this.window.setTitle(name);
        return this;
    }
    
    this.window = [[[NSWindow alloc]
                    initWithContentRect:NSMakeRect(0, 0, 1024, 768)
                    styleMask:NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
                    backing:NSBackingStoreBuffered
                    defer:false
                    ] autorelease];
    this.window.center();
    this.window.makeKeyAndOrderFront_(this.window);
    this.createWebView(name);
    
    threadDictionary[identifier] = this.window;
    return this;
}

function createWebView (name) {
    var webviewFrame = NSMakeRect(0, 0, 1024, 768);
    
    var webviewFolder   = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent()  + "/FDPreview/";
    var webviewHtmlFile = webviewFolder + "index.html";
    var requestUrl      = [NSURL fileURLWithPath:webviewHtmlFile];
    var urlRequest      = [NSMutableURLRequest requestWithURL:requestUrl];
    
    this.webView = WebView.new();
    this.webView.initWithFrame(webviewFrame);
    this.webView.mainFrame().loadRequest(urlRequest);
    this.window.contentView().addSubview(this.webView);
    this.window.setTitle(name);
    
    return this;
};

 
function exportJSON (group, path, customPanel) {
    var groupName = String(group.name());
    var groupID = String(group.objectID());
    var groupClass = String(group.className());
    var groupRotation = group.rotation();
    
    try {
        if (groupRotation != 0) group.setRotation(0);
        
        var igroup = group;
        if (groupClass == "MSSymbolInstance") {
            igroup = group.symbolMaster();
        }
        var subGroup = igroup.layers();
        
        // TODO: Override
        /*var override = group.overrides();
         console.log ("test override: " + override);  // override.affectedLayer
         console.log ("of class: " + override.className());*/

        var layerFrame = group.absoluteRect();
        var parentFrame = group.parentGroup().absoluteRect();
        
        var layerWidth = layerFrame.width();
        var layerHeight = layerFrame.height();
        var layerXpos = layerFrame.x() + layerWidth/2 - (parentFrame.x() + parentFrame.width()/2);
        var layerYpos = layerFrame.y() + layerHeight/2 - (parentFrame.y() + parentFrame.height()/2);
        
        var maxAnchorX = (customPanelDisabled) ? 0.5 : customPanel.getMaxAnchorX(groupID);
        var maxAnchorY = (customPanelDisabled) ? 0.5 : customPanel.getMaxAnchorY(groupID);
        var minAnchorX = (customPanelDisabled) ? 0.5 : customPanel.getMinAnchorX(groupID);
        var minAnchorY = (customPanelDisabled) ? 0.5 : customPanel.getMinAnchorY(groupID);
        var pivotX = (customPanelDisabled) ? 0.5 : customPanel.getPivotX(groupID);
        var pivotY = (customPanelDisabled) ? 0.5 : customPanel.getPivotY(groupID);
        
        // get components & children infor
        var compGroup = [], childGroup = [];
        var sliceLayer = null;
       
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            if (!layer.isVisible()) continue;
            
            var layerClass = String(layer.className());
            if (layerClass == "MSLayerGroup" || layerClass == "MSSymbolInstance") {
                childGroup.push(layer);
            }
            else if (layerClass == "MSSliceLayer") {
                compGroup.push(layer);
                sliceLayer = layer;
            }
            else if (layerClass == "MSTextLayer" || layerClass == "MSBitmapLayer" || layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShap" || layerClass == "MSStarShape") {
                compGroup.push(layer);
            }
        }
      
        if (compGroup.length > 1) {  // handle multiple components
            
            if (sliceLayer != null) {
                compGroup = [sliceLayer];
            }
            else {
                wrongGroups.push(groupName);
                
                var maskLayer = null;
                for (var i = 0; i < compGroup.length; i++) {
                    var layer = compGroup[i];
                    var layerName = String(layer.name());
                    if (layer.hasClippingMask() == 1) {  // handle mask
                        maskLayer = layer;
                        continue;
                    }
                    var newGroup = MSLayerGroup.new();
                    newGroup.setName(layerName);
                    newGroup.addLayers([layer]);
                    newGroup.resizeToFitChildrenWithOption(0);
                    
                    igroup.addLayers([newGroup]);
                    igroup.removeLayer(layer);
                    
                    childGroup.push(newGroup);
                }
                igroup.resizeToFitChildrenWithOption(0);
                compGroup = (maskLayer != null) ? [maskLayer] : [];
            }
        }
        var groupComponents = exportComponents(compGroup, path, customPanel);
        var groupChildren = exportChildren(childGroup, path, customPanel);
        
        var jsonObj = {
            content_type: contentType,
            version: version,
            name: groupName,
            layout: {
                "max_anchor": {"x": maxAnchorX, "y": maxAnchorY},
                "min_anchor": {"x": minAnchorX, "y": minAnchorY},
                "pivot": {"x": pivotX, "y": pivotY},
                "values": [layerXpos, layerYpos, layerWidth, layerHeight],
                "rotation_z": groupRotation
            },
            components: groupComponents,
            children: groupChildren
        };
        
        if (groupRotation != 0) group.setRotation(groupRotation);
        return jsonObj;
    }
    catch (error) {
        catchErrorAlert("exportJSON()", error);
        return {};
    }
}

function exportChildren (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var childArray = [];
    try {
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            var groupInfor = exportJSON(layer, path, customPanel);
            childArray.push(groupInfor);
        }
        return childArray;
    }
    catch (error) {
        catchErrorAlert("exportChildren()", error);
        return [];
    }
}

function exportComponents (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var compArray = [];
    try {
        var layer = subGroup[0];
        var layerClass = String(layer.className());
        var layerName = String(layer.name());
        var layerID = String(layer.parentGroup().objectID());
    
        if (layerClass == "MSTextLayer") {
            var layerText = String(layer.stringValue());
            var layerColor = "#" + String(layer.textColor().immutableModelObject().hexValue());
            var font = String(layer.font().fontName());  // String(layer.fontPostscriptName());
            var fontSize = layer.fontSize();
            var textAlign = getTextAlignString(layer.textAlignment(), layer.style().textStyle().verticalAlignment());
            var autoFit = (customPanelDisabled) ? -1 : customPanel.getTextAuto(layerID);
            
            compArray.push({
                           type: "text",
                           text: layerText,
                           font_name: font,
                           font_size: fontSize,
                           auto_fit_to: autoFit,
                           color: layerColor,
                           alignment: textAlign
                           });
        }
        else if (layerClass == "MSBitmapLayer" || layerClass == "MSSliceLayer") {
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: "#FFFFFF"
                           });
            exportImage(layer, path);
        }
        else if (layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShape" || layerClass == "MSStarShape") {
            var layerColor = String(getShapeColor(layer, layerClass));
            if (layerColor == "undefined") layerColor = "#FFFFFF";
            else layerColor = "#" + layerColor;
            
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: layerColor
                           });
            exportImage(layer, path);
        }
        return compArray;
    }
    catch (error) {
        catchErrorAlert("exportComponents()", error);
        return [];
    }
}

function catchErrorAlert (where, error) {
    console.log("--S2U catch error in " + where + ": " + error);
    [NSApp displayDialog:error withTitle:@"Error Catched!"];
}

function exportImage (layer, path) {
    var layerName = String(layer.name());
    if (isRepeat(layerName)) return;
    try {
        var options = {output: path + "images/", overwriting: true, trimmed: false};
        sketch.export(layer, options);
        imageName.push(layerName);
    }
    catch (error) {
        catchErrorAlert("exportImage()", error);
    }
}

function isRepeat (name) {
    for (var i = 0; i < imageName.length; i++) {
        if (name == imageName[i]) {
            var exist = false;
            for(var j = 0; j < repeatImages.length; j++) {
                if (name == repeatImages[j]) {
                    exist = true;
                    break;
                }
            }
            if (!exist) repeatImages.push(name);
            return true;
        }
    } return false;
}

function getTextAlignString (hAlign, vAlign) {
    if (vAlign == 0)
        return alignment = "Upper" + hAlign2String(hAlign);
    else if (vAlign == 1)
        return alignment = "Middle" + hAlign2String(hAlign);
    else if (vAlign == 2)
        return alignment = "Lower" + hAlign2String(hAlign);
    else
        return alignment = "Upper" + hAlign2String(hAlign);
}

function hAlign2String (hAlign) {
    if (hAlign == 0 || hAlign == 3)
        return "Left";
    if (hAlign == 1)
        return "Right";
    else if (hAlign == 2)
        return "Center";
    else
        return "Left";
}

function getShapeColor (layer, layerClass) {
    try {
        var fillArray = (layerClass == "MSShapePathLayer") ? layer.style().borders() : layer.style().fills();
        if (fillArray.length == 0) return "FFFFFF";
        var fill = fillArray[0];
        return fill.color().immutableModelObject().hexValue();
    }
    catch (error) {
        catchErrorAlert("getShapeColor()", error);
        return "FFFFFF";
    }
}

