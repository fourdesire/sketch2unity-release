@import 'sketch2unity.framework/sketch2unity.js'

const sketch = require('sketch/dom');
const contentType = "sketch2unity";
const version = "1.0.0";
var imageName = [];
var repeatImages = [];
var wrongGroups = [];
var customPanelDisabled = false;

var onRun = function(context) {
    const doc = context.document;
    const select = context.selection;
    
    var mocha = Mocha.sharedRuntime();
    var customPanel = mocha.valueForKey("Sketch2unity");
    if (customPanel == null || customPanel == "undefined") customPanelDisabled = true;
  
    if (doc.isDraft()) {
        [NSApp displayDialog:@"Please save the document to export." withTitle:@"Document Not Saved"];
        return;
    }
    if (doc.isDocumentEdited()) {
        var alert = [NSAlert alertWithMessageText:@"Document Not Saved" defaultButton:@"Save and Continue" alternateButton:@"Cancel" otherButton:@"Continue" informativeTextWithFormat:@"To capture the latest changes in this Sketch document, sketch2unity needs to save it first."];
        
        var response = [alert runModal];
        if (response == NSAlertDefaultReturn) {
            [doc showMessage:@"Saving document..."];
            [doc saveDocument:nil];
            while (doc.isDocumentEdited()) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            }
        }
        else if (response == NSAlertAlternateReturn) {
            return;
        }
        response = null;
        alert = null;
    }
    
    if (select.length == 0) {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Nothing Selected"];
        return;
    }
    if (select.length > 1) {
        [NSApp displayDialog:@"Please select only one Artboard Group to export." withTitle:@"Multiple Groups Selected"];
        return;
    }
    if (select[0].className() != "MSArtboardGroup" && select[0].className() != "MSLayerGroup") {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Single Layer Selected"];
        return;
    }
    var panel = NSOpenPanel.openPanel();
    panel.setCanChooseFiles(false);
    panel.setCanChooseDirectories(true);
    panel.setAllowsMultipleSelection(false);
    panel.setCanCreateDirectories(true);
    panel.setMessage("Choose a directory to place your output files");
    
    var clicked = panel.runModal();
    if (clicked == NSFileHandlingPanelOKButton) {
        var group = select[0];
        var groupName = String(group.name());
        var exportPath = panel.URL().path() + "/sketch2unity/" + groupName + "/";
        
        log("--S2U export: " + groupName + " with path: " + exportPath);
        
        var jsonObj = exportJSON(group, exportPath, customPanel);
        var file = NSString.stringWithString(JSON.stringify(jsonObj, null, "\t"));
        [file writeToFile:exportPath + groupName + ".json" atomically:true encoding:NSUTF8StringEncoding error:null];
        
        var alertMessage = groupName + ".json and images are saved to: " + exportPath + "\n";
        if (repeatImages.length > 0) {
            alertMessage = alertMessage + "\nwith the following images repeat: \n";
            for (var i = 0; i < repeatImages.length; i++) {
                alertMessage = alertMessage + (i+1) + ". " + repeatImages[i] + "\n";
            }
        }
        if (wrongGroups.length > 0) {
            alertMessage = alertMessage + "\nand more than one components in the groups: \n";
            for (var i = 0; i < wrongGroups.length; i++) {
                alertMessage = alertMessage + (i+1) + ". " + wrongGroups[i] + "\n";
            }
            alertMessage = alertMessage + "We have grouped the components for you. Please check them out.\n";
        }
        [NSApp displayDialog:alertMessage withTitle:@"Document Exported!"];
        
        imageName.length = 0;
        repeatImages.length = 0;
        wrongGroups.length = 0;

    }
    else {
        return;
    }
}

var onSelectionChanged = function(context) {
    sketch2unity.onSelectionChanged(context);
};



function exportJSON (group, path, customPanel) {
    var groupName = String(group.name());
    var groupID = String(group.objectID());
    var groupClass = String(group.className());
    var groupRotation = group.rotation();
    
    try {
        if (groupRotation != 0) group.setRotation(0);
        
        if (groupClass == "MSSymbolInstance") {
            var mgroup = group.symbolMaster();
            // TODO: deal with override
            /*var override = group.overrides();
            log ("test override: " + override);
            log ("of class: " + override.className());*/
            var subGroup = mgroup.layers();
        } else {
            var subGroup = group.layers();
        }

        var layerFrame = group.absoluteRect();
        var parentFrame = group.parentGroup().absoluteRect();
        var layerXpos = layerFrame.x() + layerFrame.width()/2 - (parentFrame.x() + parentFrame.width()/2);
        var layerYpos = layerFrame.y() + layerFrame.height()/2 - (parentFrame.y() + parentFrame.height()/2);
        
        var layerHeight = layerFrame.height();
        var layerWidth = layerFrame.width();
        if (customPanelDisabled) {
            var maxAnchorX = 0.5;
            var maxAnchorY = 0.5;
            var minAnchorX = 0.5;
            var minAnchorY = 0.5;
            var pivotX = 0.5;
            var pivotY = 0.5;
        }
        else {
            var maxAnchorX = customPanel.getMaxAnchorX(groupID);
            var maxAnchorY = customPanel.getMaxAnchorY(groupID);
            var minAnchorX = customPanel.getMinAnchorX(groupID);
            var minAnchorY = customPanel.getMinAnchorY(groupID);
            var pivotX = customPanel.getPivotX(groupID);
            var pivotY = customPanel.getPivotY(groupID);
        }
        
        // get components & children infor
        var compGroup = [], childGroup = [];
        var sliceLayer = null;
       
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            if (!layer.isVisible()) continue;
            
            var layerClass = String(layer.className());
            if (layerClass == "MSLayerGroup" || layerClass == "MSSymbolInstance") {
                childGroup.push(layer);
            }
            else if (layerClass == "MSSliceLayer") {
                compGroup.push(layer);
                sliceLayer = layer;
            }
            else if (layerClass == "MSTextLayer" || layerClass == "MSBitmapLayer" || layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShap" || layerClass == "MSStarShape") {
                compGroup.push(layer);
            }
        }
      
        if (compGroup.length > 1 && sliceLayer == null) {  // handle multiple components
            wrongGroups.push(groupName);
            
            for (var i = 0; i < compGroup.length; i++) {
                var layer = compGroup[i];
                var layerName = String(layer.name());

                var newGroup = MSLayerGroup.new();
                newGroup.setName(layerName);
                newGroup.addLayers([layer]);
                newGroup.resizeToFitChildrenWithOption(0);

                group.addLayers([newGroup]);
                group.removeLayer(layer);
                group.resizeToFitChildrenWithOption(0);

                childGroup.push(newGroup);
            }
            compGroup = [];
        }
        else if (sliceLayer != null) {
            compGroup = [sliceLayer];
        }
        var groupComponents = exportComponents(compGroup, path, customPanel);
        var groupChildren = exportChildren(childGroup, path, customPanel);
        
        var jsonObj = {
            content_type: contentType,
            version: version,
            name: groupName,
            layout: {
                "max_anchor": {"x": maxAnchorX, "y": maxAnchorY},
                "min_anchor": {"x": minAnchorX, "y": minAnchorY},
                "pivot": {"x": pivotX, "y": pivotY},
                "values": [layerXpos, layerYpos, layerWidth, layerHeight],
                "rotation_z": groupRotation
            },
            components: groupComponents,
            children: groupChildren
        };
        
        if (groupRotation != 0) group.setRotation(groupRotation);
        return jsonObj;
    }
    catch (error) {
        log("--S2U catch error in exportJSON: " + error);
        return {};
    }
}

function exportChildren (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var childArray = [];
    for (var i = 0; i < subGroup.length; i++) {
        var layer = subGroup[i];
        var layerName = String(layer.name());
        
        var groupInfor = exportJSON(layer, path, customPanel);
        childArray.push(groupInfor);
    }
    return childArray;
}

function exportComponents (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var compArray = [];
    try {
        var layer = subGroup[0];
        var layerClass = String(layer.className());
        var layerName = String(layer.name());
        var layerID = String(layer.parentGroup().objectID());
    
        if (layerClass == "MSTextLayer") {
            var layerText = String(layer.stringValue());
            var layerColor = "#" + String(layer.textColor().immutableModelObject().hexValue());
            var font = String(layer.font().fontName());  // String(layer.fontPostscriptName());
            var fontSize = layer.fontSize();
            var textAlign = textAlign2String(layer.textAlignment());
            var autoFit = (customPanelDisabled) ? -1 : customPanel.getTextAuto(layerID);
            
            compArray.push({
                           type: "text",
                           text: layerText,
                           font_name: font,
                           font_size: fontSize,
                           auto_fit_to: autoFit,
                           color: layerColor,
                           alignment: textAlign
                           });
        }
        else if (layerClass == "MSBitmapLayer" || layerClass == "MSSliceLayer") {
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: "#FFFFFF"
                           });
            exportImage(layer, path);
        }
        else if (layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShap" || layerClass == "MSStarShape") {
            var layerColor = String(getShapeColor(layer, layerClass));
            if (layerColor == "undefined") layerColor = "#FFFFFF";
            else layerColor = "#" + layerColor;
            
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: layerColor
                           });
            exportImage(layer, path);
        }
    }
    catch (error) {
        log("--S2U catch error in exportComponents: " + error);
        return [];
    }
    return compArray;
}


function exportImage (layer, path) {
    var layerName = String(layer.name());
    if (isRepeat(layerName)) return;
    try {
        var options = {output: path + "images/", overwriting: true, trimmed: false};
        sketch.export(layer, options);
        imageName.push(layerName);
    }
    catch (error) {
        log("--S2U catch error in exportImage: " + error);
    }
}

function isRepeat (name) {
    for (var i = 0; i < imageName.length; i++) {
        if (name == imageName[i]) {
            var exist = false;
            for(var j = 0; j < repeatImages.length; j++) {
                if (name == repeatImages[j]) {
                    exist = true;
                    break;
                }
            }
            if (!exist) repeatImages.push(name);
            return true;
        }
    } return false;
}

function textAlign2String (align) {
    if (align == 0) return "left";
    else if (align == 1) return "right";
    else return "center";
}

function getShapeColor (layer, layerClass) {
    try {
        var fillArray = (layerClass == "MSShapePathLayer") ? layer.style().borders() : layer.style().fills();
        if (fillArray.length == 0) return "FFFFFF";
        var fill = fillArray[0];
        return fill.color().immutableModelObject().hexValue();
    }
    catch (error) {
        log("--S2U catch error in getShapeColor: " + error);
        return "FFFFFF";
    }
}

