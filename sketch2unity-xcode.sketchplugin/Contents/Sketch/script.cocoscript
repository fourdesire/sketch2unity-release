@import 'sketch2unity.framework/sketch2unity.js'

const sketch = require('sketch/dom');
const contentType = "sketch2unity";
const version = "1.0.0";
var imageName = [];
var repeatImages = [];
var wrongGroups = [];
var customPanelDisabled = false;

var onRun = function(context) {
    const doc = context.document;
    const select = context.selection;

    var mocha = Mocha.sharedRuntime();
    var customPanel = mocha.valueForKey("Sketch2unity");
    if (customPanel == null || customPanel === undefined) {
        customPanelDisabled = true;
    }
  
    if (doc.isDraft()) {
        [NSApp displayDialog:@"Please save the document to export." withTitle:@"Document Not Saved"];
        return;
    }
    if (doc.isDocumentEdited()) {
        var alert = [NSAlert alertWithMessageText:@"Document Not Saved" defaultButton:@"Save and Continue" alternateButton:@"Cancel" otherButton:@"Continue" informativeTextWithFormat:@"To capture the latest changes in this Sketch document, sketch2unity needs to save it first."];
        
        var response = [alert runModal];
        if (response == NSAlertDefaultReturn) {
            [doc showMessage:@"Saving document..."];
            [doc saveDocument:nil];
            while (doc.isDocumentEdited()) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            }
        }
        else if (response == NSAlertAlternateReturn) {
            return;
        }
        response = null;
        alert = null;
    }
    
    if (select.length == 0) {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Nothing Selected"];
        return;
    }
    if (select.length > 1) {
        [NSApp displayDialog:@"Please select only one Artboard Group to export." withTitle:@"Multiple Groups Selected"];
        return;
    }
    if (select[0].className() != "MSArtboardGroup" && select[0].className() != "MSLayerGroup") {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Single Layer Selected"];
        return;
    }
    
    var group = select[0];
    var groupName = String(group.name());
    var exportPath = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent() + "/FDPreview/sketch2unity/" + groupName + "/";
    
    console.log("--S2U export: " + groupName + " with path: " + exportPath);
    
    var jsonObj = exportJSON(group, exportPath, customPanel);
    var file = NSString.stringWithString(JSON.stringify(jsonObj, null, "\t"));
    [file writeToFile:exportPath + groupName + ".json" atomically:true encoding:NSUTF8StringEncoding error:null];
    
    var alertMessage = groupName + ".json and images are saved to: " + exportPath + "\n";
    if (repeatImages.length > 0) {
        alertMessage = alertMessage + "\nwith the following images repeat: \n";
        for (var i = 0; i < repeatImages.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + repeatImages[i] + "\n";
        }
    }
    if (wrongGroups.length > 0) {
        alertMessage = alertMessage + "\nwith more than one components in the groups: \n";
        for (var i = 0; i < wrongGroups.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + wrongGroups[i] + "\n";
        }
        alertMessage = alertMessage + "We have grouped the components for you. Please check them out.\n";
    }
    var copyString = "./sketch2unity/" + groupName + "/" + groupName + ".json";
    var pasteboard = NSPasteboard.generalPasteboard();
    pasteboard.clearContents();
    pasteboard.writeObjects([copyString]);
    alertMessage = alertMessage + "\nYou can load them in preview by copied path now!";
    [NSApp displayDialog:alertMessage withTitle:@"Document Exported!"];

    imageName.length = 0;
    repeatImages.length = 0;
    wrongGroups.length = 0;
    
    // TODO: put this.window in upper level to avoid multiple windows and multiple load
    this.createWindow();
    this.createWebView(groupName);
    [NSApp run];
    
}

var onSelectionChanged = function(context) {
    sketch2unity.onSelectionChanged(context);
};


function createWindow () {
    this.window = [[[NSWindow alloc]
                    initWithContentRect:NSMakeRect(0, 0, 1024, 768)
                    styleMask:NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
                    backing:NSBackingStoreBuffered
                    defer:false
                    ] autorelease];
    
    this.window.center();
    this.window.makeKeyAndOrderFront_(this.window);
    
    return this;
}

function createWebView (name) {
    var webviewFrame = NSMakeRect(0, 0, 1024, 768);
    
    var webviewFolder   = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent()  + "/FDPreview/";
    var webviewHtmlFile = webviewFolder + "index.html";
    var requestUrl      = [NSURL fileURLWithPath:webviewHtmlFile];
    var urlRequest      = [NSMutableURLRequest requestWithURL:requestUrl];
    
    this.webView = WebView.new();
    this.webView.initWithFrame(webviewFrame);
    this.webView.mainFrame().loadRequest(urlRequest);
    this.window.contentView().addSubview(this.webView);
    this.window.setTitle(name);
    
    return this;
};

 
function exportJSON (group, path, customPanel) {
    var groupName = String(group.name());
    var groupID = String(group.objectID());
    var groupClass = String(group.className());
    var groupRotation = group.rotation();
    
    try {
        if (groupRotation != 0) group.setRotation(0);
        
        if (groupClass == "MSSymbolInstance") {
            var mgroup = group.symbolMaster();
            // TODO: deal with override
            /*var override = group.overrides();
            console.log ("test override: " + override);  // override.affectedLayer
            console.log ("of class: " + override.className());*/
            var subGroup = mgroup.layers();
        } else {
            var subGroup = group.layers();
        }

        var layerFrame = group.absoluteRect();
        var parentFrame = group.parentGroup().absoluteRect();
        var layerXpos = layerFrame.x() + layerFrame.width()/2 - (parentFrame.x() + parentFrame.width()/2);
        var layerYpos = layerFrame.y() + layerFrame.height()/2 - (parentFrame.y() + parentFrame.height()/2);
        
        var layerHeight = layerFrame.height();
        var layerWidth = layerFrame.width();
        if (customPanelDisabled) {
            var maxAnchorX = 0.5;
            var maxAnchorY = 0.5;
            var minAnchorX = 0.5;
            var minAnchorY = 0.5;
            var pivotX = 0.5;
            var pivotY = 0.5;
        }
        else {
            var maxAnchorX = customPanel.getMaxAnchorX(groupID);
            var maxAnchorY = customPanel.getMaxAnchorY(groupID);
            var minAnchorX = customPanel.getMinAnchorX(groupID);
            var minAnchorY = customPanel.getMinAnchorY(groupID);
            var pivotX = customPanel.getPivotX(groupID);
            var pivotY = customPanel.getPivotY(groupID);
        }
        
        // get components & children infor
        var compGroup = [], childGroup = [];
        var sliceLayer = null;
       
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            if (!layer.isVisible()) continue;
            
            var layerClass = String(layer.className());
            if (layerClass == "MSLayerGroup" || layerClass == "MSSymbolInstance") {
                childGroup.push(layer);
            }
            else if (layerClass == "MSSliceLayer") {
                compGroup.push(layer);
                sliceLayer = layer;
            }
            else if (layerClass == "MSTextLayer" || layerClass == "MSBitmapLayer" || layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShap" || layerClass == "MSStarShape") {
                if (layer.hasClippingMask() == 1) {
                    layer.setIsVisible(false);
                    continue;
                }
                compGroup.push(layer);
            }
        }
      
        if (compGroup.length > 1) {  // handle multiple components
            
            if (sliceLayer != null) {
                compGroup = [sliceLayer];
            }
            else {
                wrongGroups.push(groupName);
                
                for (var i = 0; i < compGroup.length; i++) {
                    var layer = compGroup[i];
                    var layerName = String(layer.name());
                    
                    var newGroup = MSLayerGroup.new();
                    newGroup.setName(layerName);
                    newGroup.addLayers([layer]);
                    newGroup.resizeToFitChildrenWithOption(0);
                    
                    if (groupClass == "MSSymbolInstance") {
                        mgroup.addLayers([newGroup]);
                        mgroup.removeLayer(layer);
                    }
                    else {
                        group.addLayers([newGroup]);
                        group.removeLayer(layer);
                    }
                    childGroup.push(newGroup);
                }
                compGroup = [];
            }
        }
        var groupComponents = exportComponents(compGroup, path, customPanel);
        var groupChildren = exportChildren(childGroup, path, customPanel);
        
        var jsonObj = {
            content_type: contentType,
            version: version,
            name: groupName,
            layout: {
                "max_anchor": {"x": maxAnchorX, "y": maxAnchorY},
                "min_anchor": {"x": minAnchorX, "y": minAnchorY},
                "pivot": {"x": pivotX, "y": pivotY},
                "values": [layerXpos, layerYpos, layerWidth, layerHeight],
                "rotation_z": groupRotation
            },
            components: groupComponents,
            children: groupChildren
        };
        
        if (groupRotation != 0) group.setRotation(groupRotation);
        return jsonObj;
    }
    catch (error) {
        console.log("--S2U catch error in exportJSON: " + error);
        return {};
    }
}

function exportChildren (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var childArray = [];
    try {
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            var groupInfor = exportJSON(layer, path, customPanel);
            childArray.push(groupInfor);
        }
        return childArray;
    }
    catch (error) {
        console.log("--S2U catch error in exportChildren: " + error);
        return [];
    }
}

function exportComponents (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var compArray = [];
    try {
        var layer = subGroup[0];
        var layerClass = String(layer.className());
        var layerName = String(layer.name());
        var layerID = String(layer.parentGroup().objectID());
    
        if (layerClass == "MSTextLayer") {
            var layerText = String(layer.stringValue());
            var layerColor = "#" + String(layer.textColor().immutableModelObject().hexValue());
            var font = String(layer.font().fontName());  // String(layer.fontPostscriptName());
            var fontSize = layer.fontSize();
            var textAlign = textAlign2String(layer.textAlignment());
            var autoFit = (customPanelDisabled) ? -1 : customPanel.getTextAuto(layerID);
            
            compArray.push({
                           type: "text",
                           text: layerText,
                           font_name: font,
                           font_size: fontSize,
                           auto_fit_to: autoFit,
                           color: layerColor,
                           alignment: textAlign
                           });
        }
        else if (layerClass == "MSBitmapLayer" || layerClass == "MSSliceLayer") {
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: "#FFFFFF"
                           });
            exportImage(layer, path);
        }
        else if (layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShap" || layerClass == "MSStarShape") {
            var layerColor = String(getShapeColor(layer, layerClass));
            if (layerColor == "undefined") layerColor = "#FFFFFF";
            else layerColor = "#" + layerColor;
            
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: layerColor
                           });
            exportImage(layer, path);
        }
        return compArray;
    }
    catch (error) {
        console.log("--S2U catch error in exportComponents: " + error);
        return [];
    }
}


function exportImage (layer, path) {
    var layerName = String(layer.name());
    if (isRepeat(layerName)) return;
    try {
        var options = {output: path + "images/", overwriting: true, trimmed: false};
        sketch.export(layer, options);
        imageName.push(layerName);
    }
    catch (error) {
        console.log("--S2U catch error in exportImage: " + error);
    }
}

function isRepeat (name) {
    for (var i = 0; i < imageName.length; i++) {
        if (name == imageName[i]) {
            var exist = false;
            for(var j = 0; j < repeatImages.length; j++) {
                if (name == repeatImages[j]) {
                    exist = true;
                    break;
                }
            }
            if (!exist) repeatImages.push(name);
            return true;
        }
    } return false;
}

function textAlign2String (align) {
    if (align == 0) return "left";
    else if (align == 1) return "right";
    else return "center";
}

function getShapeColor (layer, layerClass) {
    try {
        var fillArray = (layerClass == "MSShapePathLayer") ? layer.style().borders() : layer.style().fills();
        if (fillArray.length == 0) return "FFFFFF";
        var fill = fillArray[0];
        return fill.color().immutableModelObject().hexValue();
    }
    catch (error) {
        console.log("--S2U catch error in getShapeColor: " + error);
        return "FFFFFF";
    }
}

