@import 'sketch2unity.framework/sketch2unity.js';
const sketch = require('sketch/dom');
const contentType = "sketch2unity";
const version = "1.0.0";

var imageName = [];
var repeatImages = [];
var wrongGroups = [];
var errorMessages = [];
var customPanelDisabled = false;


/**
 * Start the script and run every time the plugin shortcut or menu item is fired
 * Export json file & images of selected UI
 *
 * @param {object} context: provided by Sketch with information of currently running app
 *
 */
var onRun = function (context) {
    const doc = context.document;
    const select = context.selection;

    var mocha = Mocha.sharedRuntime();
    var customPanel = mocha.valueForKey("Sketch2Unity");
    if (customPanel == null || customPanel === undefined) {
        customPanelDisabled = true;
        errorMessages.push("--S2U catch error in onRun(): customPanel is null or undefined");
    }

    if (doc.isDraft()) {
        [NSApp displayDialog:@"Please save the document to export." withTitle:@"Document Not Saved"];
        return;
    }
    if (doc.isDocumentEdited()) {
        var alert = [NSAlert alertWithMessageText:@"Document Not Saved" defaultButton:@"Save and Continue" alternateButton:@"Cancel" otherButton:@"Continue" informativeTextWithFormat:@"To capture the latest changes in this Sketch document, sketch2unity needs to save it first."];
        
        var response = [alert runModal];
        if (response == NSAlertDefaultReturn) {
            [doc showMessage:@"Saving document..."];
            [doc saveDocument:nil];
            while (doc.isDocumentEdited()) {
                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
            }
        }
        else if (response == NSAlertAlternateReturn) {
            return;
        }
        response = null;
        alert = null;
    }
    
    if (select.length == 0) {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Nothing Selected"];
        return;
    }
    if (select.length > 1) {
        [NSApp displayDialog:@"Please select only one Artboard Group to export." withTitle:@"Multiple Groups Selected"];
        return;
    }
    
    var group = select[0];
    var groupClass = String(group.className());
    if (groupClass != "MSArtboardGroup" && groupClass != "MSLayerGroup") {
        [NSApp displayDialog:@"Please select the Artboard Group to export." withTitle:@"Single Layer Selected"];
        return;
    }
    
    var groupName = String(group.name());
    var d = new Date();
    var timestamp = "-" + d.getFullYear() + "-" + Number(d.getMonth()+1) + "-" + d.getDate() + "-" + d.getHours() + "." + d.getMinutes() + "." + d.getSeconds();
    var exportPath = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent() + "/FDPreview/sketch2unity/" + groupName + timestamp + "/";
    var relativePath = "./sketch2unity/" + groupName + timestamp + "/" + groupName + ".json";
    console.log("--S2U export: " + groupName + " with path: " + exportPath);
    
    var jsonObj = exportJSON(group, exportPath, customPanel);
    var file = NSString.stringWithString(JSON.stringify(jsonObj, null, "\t"));
    [file writeToFile:exportPath + groupName + ".json" atomically:true encoding:NSUTF8StringEncoding error:null];
    
    var exportMessage = getExportMessage(groupName, relativePath, exportPath);
    [NSApp displayDialog:exportMessage withTitle:@"Document Exported!"];
    if (errorMessages.length > 0) catchErrorAlert();
    
    imageName.length = 0;
    repeatImages.length = 0;
    wrongGroups.length = 0;
    errorMessages.length = 0;
    
    this.loadWindow(relativePath);
    [NSApp run];
}

var onSelectionChanged = function(context) {
    sketch2unity.onSelectionChanged(context);
};



/**
 * Create json object for group, get its components & children infor, and handle creating groups automatically
 *
 * @param {MSLayerGroup or MSSymbolInstance} group
 * @param {String} path: UI export path
 * @param {MochaRuntime} customPanel: shared runtime custom panel
 * @returns {jsonObj}
 */
function exportJSON (group, path, customPanel) {
    var groupName = String(group.name());
    var groupID = String(group.objectID());
    var groupClass = String(group.className());
    var groupRotation = group.rotation();
    
    try {
        var name = groupName;
        while (name.includes("/")) {
            name = name.replace("/", "-");
        }
        if (groupRotation != 0) group.setRotation(0);
        
        var igroup = group;
        if (groupClass == "MSSymbolInstance") {
            igroup = group.symbolMaster();
        }
        var subGroup = igroup.layers();

        var groupFrame = group.absoluteRect();
        var parentFrame = group.parentGroup().absoluteRect();
        var groupWidth = groupFrame.width();
        var groupHeight = groupFrame.height();
        var groupXpos = groupFrame.x() + groupWidth/2 - (parentFrame.x() + parentFrame.width()/2);
        var groupYpos = groupFrame.y() + groupHeight/2 - (parentFrame.y() + parentFrame.height()/2);
        var maxAnchorX = (customPanelDisabled) ? 0.5 : customPanel.getMaxAnchorX(groupID);
        var maxAnchorY = (customPanelDisabled) ? 0.5 : customPanel.getMaxAnchorY(groupID);
        var minAnchorX = (customPanelDisabled) ? 0.5 : customPanel.getMinAnchorX(groupID);
        var minAnchorY = (customPanelDisabled) ? 0.5 : customPanel.getMinAnchorY(groupID);
        var pivotX = (customPanelDisabled) ? 0.5 : customPanel.getPivotX(groupID);
        var pivotY = (customPanelDisabled) ? 0.5 : customPanel.getPivotY(groupID);
        
        // get components & children infor
        var compGroup = [], childGroup = [];
        var sliceLayer = null, maskLayer = null;
        
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            if (!layer.isVisible()) continue;
            
            var layerName = String(layer.name());
            var layerClass = String(layer.className());

            if (layerClass == "MSLayerGroup" || layerClass == "MSSymbolInstance") {
                childGroup.push(layer);
            }
            else if (layerClass == "MSTextLayer" || layerClass == "MSBitmapLayer") {
                compGroup.push(layer);
            }
            else if (layerClass == "MSSliceLayer") {
                compGroup.push(layer);
                sliceLayer = layer;
            }
            else if (layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShape" || layerClass == "MSStarShape") {
                compGroup.push(layer);
                if (layer.hasClippingMask() == 1) {
                    maskLayer = layer;
                }
            }
        }
        
        // handle create folders
        if (compGroup.length == 1 && childGroup.length != 0) {  //case1: create a folder
            var layer = compGroup[0];
            var layerFrame = layer.absoluteRect();
            
            if (!equalFrames(layerFrame, groupFrame) && maskLayer == null) {
                wrongGroups.push(groupName);
                childGroup = wrapLayer (layer, igroup, childGroup);
                compGroup.length = 0;
            }
        }
        else if (compGroup.length > 1) {
            
            if (sliceLayer != null) {  // case2: with slice
                compGroup = [sliceLayer];
            }
            else if (maskLayer != null) {  // case3: create folders with mask
                wrongGroups.push(groupName);
                for (var i = 0; i < compGroup.length; i++) {
                    var layer = compGroup[i];
                    if (layer == maskLayer) continue;
                    
                    childGroup = wrapLayer (layer, igroup, childGroup);
                }
                igroup.resizeToFitChildrenWithOption(0);
                compGroup = [maskLayer];
            }
            else {  // case4: create folders without mask
                wrongGroups.push(groupName);
                var compLayer = null;
                for (var i = 0; i < compGroup.length; i++) {
                    var layer = compGroup[i];
                    var layerFrame = layer.absoluteRect();
                    
                    if (equalFrames(layerFrame, groupFrame) && compLayer == null) {
                        compLayer = layer;
                        continue;
                    }
                    childGroup = wrapLayer (layer, igroup, childGroup);
                }
                igroup.resizeToFitChildrenWithOption(0);
                if (compLayer == null) {
                    compGroup.length = 0;
                }
                else {
                    compGroup = [compLayer];
                }
            }
        }
        
        var groupComponents = exportComponents(compGroup, path, customPanel);
        var groupChildren = exportChildren(childGroup, path, customPanel);
        
        var jsonObj = {
            content_type: contentType,
            version: version,
            name: name,
            layout: {
                "max_anchor": {"x": maxAnchorX, "y": maxAnchorY},
                "min_anchor": {"x": minAnchorX, "y": minAnchorY},
                "pivot": {"x": pivotX, "y": pivotY},
                "values": [groupXpos, groupYpos, groupWidth, groupHeight],
                "rotation_z": groupRotation
            },
            components: groupComponents,
            children: groupChildren
        };
        
        if (groupRotation != 0) group.setRotation(groupRotation);
        return jsonObj;
    }
    catch (error) {
        errorMessages.push("--S2U catch error in exportJSON(): " + error);
        return {};
    }
}

/**
 * Create children array of groups in subGroup
 *
 * @param {Array.MSLayerGroup or MSSymbolInstance} subGroup
 * @param {String} path
 * @param {MochaRuntime} customPanel
 * @returns {Array.jsonObj} childArray
 */
function exportChildren (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var childArray = [];
    try {
        for (var i = 0; i < subGroup.length; i++) {
            var layer = subGroup[i];
            var groupInfor = exportJSON(layer, path, customPanel);
            childArray.push(groupInfor);
        }
        return childArray;
    }
    catch (error) {
        errorMessages.push("--S2U catch error in exportChildren(): " + error);
        return [];
    }
}

/**
 * Create components array of layers in subGroup
 *
 * @param {Array.MSTextLayer, MSBitmapLayer, MSSliceLayer, MSShapeGroup, MSShapePathLayer, MSRectangleShape, MSOvalShape, MSTriangleShape, MSPolygonShape or MSStarShape} subGroup
 * @param {String} path
 * @param {MochaRuntime} customPanel
 * @returns {Array.jsonObj} compArray
 */
function exportComponents (subGroup, path, customPanel) {
    if (subGroup.length == 0) return [];
    
    var compArray = [];
    try {
        var layer = subGroup[0];
        var layerClass = String(layer.className());
        var layerName = String(layer.name());
        var layerID = String(layer.parentGroup().objectID());
        
        if (layerClass == "MSTextLayer") {
            var layerText = String(layer.stringValue());
            var layerColor = "#" + String(layer.textColor().immutableModelObject().hexValue());
            var font = String(layer.font().fontName());  // String(layer.fontPostscriptName());
            var fontSize = layer.fontSize();
            var textAlign = getTextAlignString(layer.textAlignment(), layer.style().textStyle().verticalAlignment());
            var autoFit = (customPanelDisabled) ? -1 : customPanel.getTextAuto(layerID);
            
            compArray.push({
                           type: "text",
                           text: layerText,
                           font_name: font,
                           font_size: fontSize,
                           auto_fit_to: autoFit,
                           color: layerColor,
                           alignment: textAlign
                           });
        }
        else if (layerClass == "MSBitmapLayer" || layerClass == "MSSliceLayer") {
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: "#FFFFFF"
                           });
            exportImage(layer, path);
        }
        else if (layerClass == "MSShapeGroup" || layerClass == "MSShapePathLayer" || layerClass == "MSRectangleShape" || layerClass == "MSOvalShape" || layerClass == "MSTriangleShape" || layerClass == "MSPolygonShape" || layerClass == "MSStarShape") {
            var layerColor = String(getShapeColor(layer, layerClass));
            if (layerColor == "undefined") layerColor = "#FFFFFF";
            else layerColor = "#" + layerColor;
            
            compArray.push({
                           type: "image",
                           image: layerName,
                           color: layerColor
                           });
            exportImage(layer, path);
        }
        return compArray;
    }
    catch (error) {
        errorMessages.push("--S2U catch error in exportComponents(): " + error);
        return [];
    }
}


/**
 * Wrap layer with a group
 *
 * @param {Array.MSLayer} layer
 * @param {MSLayerGroup or MSSymbolMaster} parentGroup: parent of layer
 * @param {Array.MSLayerGroup or MSSymbolInstance} childGroup
 * @returns {Array.jsonObj}
 */
function wrapLayer (layer, parentGroup, childGroup) {
    var layerName = String(layer.name());
    var parentIndex = parentGroup.indexOfLayer(layer);
    var childIndex = getLayerIndexInChild(layer, parentGroup, childGroup);
    
    var newGroup = MSLayerGroup.new();
    newGroup.setName(layerName);
    newGroup.addLayers([layer]);
    newGroup.resizeToFitChildrenWithOption(0);
    newGroup.setShouldBreakMaskChain(layer.shouldBreakMaskChain());
    
    parentGroup.addLayers([newGroup]);
    parentGroup.removeLayer(layer);
    
    MSLayerMovement.moveToBack([newGroup]);
    for (var i = 0; i < parentIndex; i++) {
        MSLayerMovement.moveForward([newGroup]);
    }
    childGroup.splice(childIndex, 0, newGroup);
    return childGroup;
}

/**
 * Get index of layer to be inserted in childGroup
 *
 * @param {Array.MSLayer} layer
 * @param {MSLayerGroup or MSSymbolMaster} parentGroup: parent of layer
 * @param {Array.MSLayerGroup or MSSymbolInstance} childGroup
 * @returns {Number}
 */
function getLayerIndexInChild (layer, parentGroup, childGroup) {
    var originalIndex = parentGroup.indexOfLayer(layer);
    if (originalIndex == 0) return 0;

    var subGroup = parentGroup.layers();
    var prevLayer = null;
    var prevIndex = -1;
    for (var i = 0; i < originalIndex; i++) {
        var layer = subGroup[i];
        var index = childGroup.indexOf(layer);
        if (index >= 0) {
            prevIndex = index;
            prevLayer = layer;
        }
    }
    return (prevIndex >= 0) ? prevIndex + 1 : 0;
}

/**
 * Compare whether frame1 & frame2 are equal
 *
 * @param {MSAbsoluteRect} frame1
 * @param {MSAbsoluteRect} frame2
 * @returns {Boolean}
 */
function equalFrames (frame1, frame2) {
    var frame1Width = frame1.width();
    var frame1Height = frame1.height();
    var frame1Xpos = frame1.x();
    var frame1Ypos = frame1.y();
    
    var frame2Width = frame2.width();
    var frame2Height = frame2.height();
    var frame2Xpos = frame2.x();
    var frame2Ypos = frame2.y();
    
    if (frame1Width == frame2Width && frame1Height == frame2Height && frame1Xpos == frame2Xpos && frame1Ypos == frame2Ypos) return true;
    return false;
}

/**
 * Export image of layer at path
 *
 * @param {MSBitmapLayer, MSSliceLayer, MSShapeGroup, MSShapePathLayer, MSRectangleShape, MSOvalShape, MSTriangleShape, MSPolygonShape or MSStarShape} layer
 * @param {String} path
 */
function exportImage (layer, path) {
    var layerName = String(layer.name());
    if (isRepeat(layerName)) return;
    try {
        var options = {output: path + "images/", overwriting: true, trimmed: false};
        sketch.export(layer, options);
        imageName.push(layerName);
    }
    catch (error) {
        errorMessages.push("--S2U catch error in exportImage(): " + error);
    }
}

/**
 * Check whether image of name has been exported
 *
 * @param {String} name
 * @returns {Boolean}
 */
function isRepeat (name) {
    for (var i = 0; i < imageName.length; i++) {
        if (name == imageName[i]) {
            var exist = false;
            for(var j = 0; j < repeatImages.length; j++) {
                if (name == repeatImages[j]) {
                    exist = true;
                    break;
                }
            }
            if (!exist) repeatImages.push(name);
            return true;
        }
    } return false;
}

/**
 * Get text vertical & horizontal alignment string
 *
 * @param {String} hAlign: horizontal alignment
 * @param {String} vAlign: vertical alignment
 * @returns {String}
 */
function getTextAlignString (hAlign, vAlign) {
    if (vAlign == 0)
        return alignment = "Upper" + hAlign2String(hAlign);
    else if (vAlign == 1)
        return alignment = "Middle" + hAlign2String(hAlign);
    else if (vAlign == 2)
        return alignment = "Lower" + hAlign2String(hAlign);
    else
        return alignment = "Upper" + hAlign2String(hAlign);
}

/**
 * Get text horizontal alignment string
 *
 * @param {String} hAlign: horizontal alignment
 * @returns {String}
 */
function hAlign2String (hAlign) {
    if (hAlign == 0 || hAlign == 3)
        return "Left";
    if (hAlign == 1)
        return "Right";
    else if (hAlign == 2)
        return "Center";
    else
        return "Left";
}

/**
 * Get shape color string
 *
 * @param {MSShapeGroup, MSShapePathLayer, MSRectangleShape, MSOvalShape, MSTriangleShape, MSPolygonShape or MSStarShape} layer
 * @param {String} layerClass: class of layer
 * @returns {String}
 */
function getShapeColor (layer, layerClass) {
    try {
        var fillArray = (layerClass == "MSShapePathLayer") ? layer.style().borders() : layer.style().fills();
        if (fillArray.length == 0) return "FFFFFF";
        
        var fill = fillArray[0];
        return fill.color().immutableModelObject().hexValue();
    }
    catch (error) {
        errorMessages.push("--S2U catch error in getShapeColor(): " + error);
        return "FFFFFF";
    }
}


/**
 * Create window and load UI in window
 *
 * @param {String} path: relative export path of exported json file
 * @returns {NSWindow}
 */
function loadWindow (path) {
    var threadDictionary = NSThread.mainThread().threadDictionary();
    var identifier = "Sketch2UnityPreview";
    
    if (threadDictionary[identifier]) {
        this.window = threadDictionary[identifier];
        this.window.makeKeyAndOrderFront_(this.window);
        this.window.setTitle(path);
        
        var windowObject = this.window.contentView().subviews()[0].windowScriptObject();
        [windowObject evaluateWebScript:[NSString stringWithFormat:@"gameInstance.SendMessage('Button', 'ReceiveMessage', '%@')", [window title]]];
        return this;
    }
    
    this.window = [[[NSWindow alloc]
                    initWithContentRect:NSMakeRect(0, 0, 1024, 768)
                    styleMask:NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
                    backing:NSBackingStoreBuffered
                    defer:false
                    ] autorelease];
    this.window.center();
    this.window.makeKeyAndOrderFront_(this.window);
    this.createWebView(path);
    threadDictionary[identifier] = this.window;
    
    var closeButton = this.window.standardWindowButton(NSWindowCloseButton);
    closeButton.setCOSJSTargetFunction(function(sender) {
                                       this.window.close();
                                       threadDictionary.removeObjectForKey(identifier);
                                       COScript.currentCOScript().setShouldKeepAround_(false);
                                       });
    
    // TODO: send message after unity finishes loading
    //var windowObject = this.window.contentView().subviews()[0].windowScriptObject();
    //var finishUnityLoad = [windowObject evaluateWebScript:[NSString stringWithFormat:@"finishUnityLoad"]];
    //[windowObject evaluateWebScript:[NSString stringWithFormat:@"gameInstance.SendMessage('Button', 'ReceiveMessage', '%@')", [window title]]];

    return this;
}

/**
 * Create webview in window
 *
 * @param {String} path: relative export path of exported json file
 * @returns {NSWebview}
 */
function createWebView (path) {
    var webviewFrame = NSMakeRect(0, 0, 1024, 768);
    var webviewFolder   = COScript.currentCOScript().env().scriptURL.path().stringByDeletingLastPathComponent()  + "/FDPreview/";
    var webviewHtmlFile = webviewFolder + "index.html";
    var requestUrl      = [NSURL fileURLWithPath:webviewHtmlFile];
    var urlRequest      = [NSMutableURLRequest requestWithURL:requestUrl];
    
    this.webView = WebView.new();
    this.webView.initWithFrame(webviewFrame);
    this.webView.mainFrame().loadRequest(urlRequest);
    this.window.contentView().addSubview(this.webView);
    this.window.setTitle(path);

    return this;
}

/**
 * Get export message and copy relativePath in pasteboard
 *
 * @param {String} name: UI name
 * @param {String} relativePath: relative export path of exported json file
 * @param {String} exportPath: absolute UI export path
 * @returns {String} alertMessage
 */
function getExportMessage (name, relativePath, exportPath) {
    var alertMessage = name + ".json and images are saved to: " + exportPath + "\n";
    
    if (repeatImages.length > 0) {
        alertMessage = alertMessage + "\nwith the following images repeat: \n";
        for (var i = 0; i < repeatImages.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + repeatImages[i] + "\n";
        }
    }
    if (wrongGroups.length > 0) {
        alertMessage = alertMessage + "\nwith more than one components in the groups: \n";
        for (var i = 0; i < wrongGroups.length; i++) {
            alertMessage = alertMessage + (i+1) + ". " + wrongGroups[i] + "\n";
        }
    }
    var pasteboard = NSPasteboard.generalPasteboard();
    pasteboard.clearContents();
    pasteboard.writeObjects([relativePath]);
    alertMessage = alertMessage + "\nYou can load them in preview by copied path now!";
    
    return alertMessage;
}

/**
 * Show catch error alert
 */
function catchErrorAlert () {
    var errorMessage;
    for (var i = 0; i < errorMessages.length; i++) {
        console.log(errorMessages[i] + "\n");
        errorMessage = errorMessage + errorMessages[i] + "\n";
    }
    [NSApp displayDialog:errorMessage withTitle:@"Error Catched!"];
}

